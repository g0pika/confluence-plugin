import React from 'react';
import { createAndFireEvent, withAnalyticsContext, withAnalyticsEvents, } from '@atlaskit/analytics-next';
import { ASC, DESC, LARGE, SMALL } from '../internal/constants';
import { assertIsSortable, getPageRows, validateSortKey, } from '../internal/helpers';
import { Caption, PaginationWrapper, Table } from '../styled/DynamicTable';
import { EmptyViewContainer, EmptyViewWithFixedHeight, } from '../styled/EmptyBody';
import { name as packageName, version as packageVersion, } from '../version.json';
import Body from './Body';
import LoadingContainer from './LoadingContainer';
import LoadingContainerAdvanced from './LoadingContainerAdvanced';
import ManagedPagination from './managedPagination';
import RankableTableBody from './rankable/Body';
import TableHead from './TableHead';
function toggleSortOrder(currentSortOrder) {
    switch (currentSortOrder) {
        case DESC:
            return ASC;
        case ASC:
            return DESC;
        default:
            return currentSortOrder;
    }
}
class DynamicTable extends React.Component {
    constructor() {
        super(...arguments);
        this.state = {
            isRanking: false,
        };
        this.onSort = (item) => () => {
            const { sortKey, sortOrder, onSort, isRankable } = this.props;
            const { key } = item;
            if (!key) {
                return;
            }
            if (onSort && isRankable && key === sortKey && sortOrder === DESC) {
                onSort({ key: null, sortOrder: null, item });
                return;
            }
            const sortOrderFormatted = key !== sortKey ? ASC : toggleSortOrder(sortOrder);
            if (onSort) {
                onSort({ key, item, sortOrder: sortOrderFormatted });
            }
        };
        this.onSetPage = (page, event) => {
            const { onSetPage } = this.props;
            if (onSetPage) {
                onSetPage(page, event);
            }
        };
        this.onRankStart = (params) => {
            this.setState({
                isRanking: true,
            });
            if (this.props.onRankStart) {
                this.props.onRankStart(params);
            }
        };
        this.onRankEnd = (params) => {
            this.setState({
                isRanking: false,
            });
            if (this.props.onRankEnd) {
                this.props.onRankEnd(params);
            }
        };
        this.getSpinnerSize = () => {
            const { page, rows, rowsPerPage, loadingSpinnerSize } = this.props;
            if (loadingSpinnerSize) {
                return loadingSpinnerSize;
            }
            return getPageRows(rows || [], page, rowsPerPage).length > 2
                ? LARGE
                : SMALL;
        };
        this.renderEmptyBody = () => {
            const { emptyView, isLoading } = this.props;
            if (isLoading) {
                return React.createElement(EmptyViewWithFixedHeight, null);
            }
            return emptyView && React.createElement(EmptyViewContainer, null, emptyView);
        };
    }
    UNSAFE_componentWillMount() {
        validateSortKey(this.props.sortKey, this.props.head);
        assertIsSortable(this.props.head);
    }
    UNSAFE_componentWillReceiveProps(nextProps) {
        if (this.props.sortKey !== nextProps.sortKey ||
            this.props.head !== nextProps.head) {
            validateSortKey(nextProps.sortKey, nextProps.head);
        }
        if (this.props.head !== nextProps.head) {
            assertIsSortable(nextProps.head);
        }
    }
    render() {
        const { caption, head, highlightedRowIndex, isFixedSize, page, rows, rowsPerPage, sortKey, sortOrder, isLoading, isRankable, isRankingDisabled, paginationi18n, onPageRowsUpdate, testId, } = this.props;
        const rowsLength = rows && rows.length;
        const bodyProps = {
            highlightedRowIndex,
            rows,
            head,
            sortKey,
            sortOrder,
            rowsPerPage,
            page,
            isFixedSize: isFixedSize || false,
            onPageRowsUpdate,
            ref: (el) => {
                this.tableBody = el;
            },
            testId,
        };
        const totalPages = rowsLength && rowsPerPage ? Math.ceil(rowsLength / rowsPerPage) : 0;
        const rowsExist = !!rowsLength;
        const spinnerSize = this.getSpinnerSize();
        const emptyBody = this.renderEmptyBody();
        const canRank = isRankable && !sortKey;
        return (React.createElement(React.Fragment, null,
            React.createElement(LoadingContainerAdvanced, { isLoading: isLoading && rowsExist, spinnerSize: spinnerSize, targetRef: () => this.tableBody },
                React.createElement(Table, { isFixedSize: isFixedSize, "data-testid": testId && `${testId}--table` },
                    !!caption && React.createElement(Caption, null, caption),
                    head && (React.createElement(TableHead, { head: head, onSort: this.onSort, sortKey: sortKey, sortOrder: sortOrder, isRanking: this.state.isRanking, isRankable: canRank, testId: testId })),
                    rowsExist &&
                        (canRank ? (React.createElement(RankableTableBody, Object.assign({}, bodyProps, { isRanking: this.state.isRanking, onRankStart: this.onRankStart, onRankEnd: this.onRankEnd, isRankingDisabled: isRankingDisabled || isLoading || false }))) : (React.createElement(Body, Object.assign({}, bodyProps)))))),
            !totalPages ? null : (React.createElement(PaginationWrapper, null,
                React.createElement(ManagedPagination, { value: page, onChange: this.onSetPage, total: totalPages, i18n: paginationi18n }))),
            !rowsExist && emptyBody && (React.createElement(LoadingContainer, { isLoading: isLoading, spinnerSize: LARGE }, emptyBody))));
    }
}
DynamicTable.defaultProps = {
    isLoading: false,
    isFixedSize: false,
    rowsPerPage: Infinity,
    onSetPage: () => { },
    onSort: () => { },
    page: 1,
    isRankable: false,
    isRankingDisabled: false,
    onRankStart: () => { },
    onRankEnd: () => { },
    paginationi18n: {
        prev: 'Prev',
        next: 'Next',
    },
};
export { DynamicTable as DynamicTableWithoutAnalytics };
const createAndFireEventOnAtlaskit = createAndFireEvent('atlaskit');
export default withAnalyticsContext({
    componentName: 'dynamicTable',
    packageName,
    packageVersion,
})(withAnalyticsEvents({
    onSort: createAndFireEventOnAtlaskit({
        action: 'sorted',
        actionSubject: 'dynamicTable',
        attributes: {
            componentName: 'dynamicTable',
            packageName,
            packageVersion,
        },
    }),
    onRankEnd: createAndFireEventOnAtlaskit({
        action: 'ranked',
        actionSubject: 'dynamicTable',
        attributes: {
            componentName: 'dynamicTable',
            packageName,
            packageVersion,
        },
    }),
})(DynamicTable));
//# sourceMappingURL=Stateless.js.map