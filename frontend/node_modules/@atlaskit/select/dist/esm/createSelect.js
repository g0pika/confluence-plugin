import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _excluded = ["styles", "validationState", "isInvalid", "spacing", "isMulti", "appearance", "ariaLiveMessages"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
import React, { Component } from 'react';
import { mergeStyles } from 'react-select';
import memoizeOne from 'memoize-one';
import isEqual from 'react-fast-compare';
import { Input } from './components/input-aria-describedby';
import { ClearIndicator, DropdownIndicator, LoadingIndicator, MultiValueRemove, IndicatorSeparator } from './components';
import baseStyles from './styles';
import { onFocus, isOptionsGrouped } from './utils/grouped-options-announcement';
export default function createSelect(WrappedComponent) {
  var _class;
  return _class = /*#__PURE__*/function (_Component) {
    _inherits(AtlaskitSelect, _Component);
    var _super = _createSuper(AtlaskitSelect);
    function AtlaskitSelect(props) {
      var _this;
      _classCallCheck(this, AtlaskitSelect);
      _this = _super.call(this, props);
      _defineProperty(_assertThisInitialized(_this), "components", {});
      _defineProperty(_assertThisInitialized(_this), "select", null);
      _defineProperty(_assertThisInitialized(_this), "cacheComponents", function (components) {
        _this.components = _objectSpread({
          ClearIndicator: ClearIndicator ? ClearIndicator : undefined,
          DropdownIndicator: DropdownIndicator,
          LoadingIndicator: LoadingIndicator,
          MultiValueRemove: MultiValueRemove,
          IndicatorSeparator: IndicatorSeparator
        }, components);
      });
      _defineProperty(_assertThisInitialized(_this), "onSelectRef", function (ref) {
        _this.select = ref;
      });
      _this.cacheComponents = memoizeOne(_this.cacheComponents, isEqual).bind(_assertThisInitialized(_this));
      _this.cacheComponents(props.components || {});
      return _this;
    }
    _createClass(AtlaskitSelect, [{
      key: "UNSAFE_componentWillReceiveProps",
      value: function UNSAFE_componentWillReceiveProps(nextProps) {
        this.cacheComponents(nextProps.components);
      }
    }, {
      key: "focus",
      value: function focus() {
        if (this.select) {
          this.select.focus();
        }
      }
    }, {
      key: "blur",
      value: function blur() {
        if (this.select) {
          this.select.blur();
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var descriptionId = this.props['aria-describedby'];
        if (!this.props.isSearchable && descriptionId) {
          var _this$select;
          // when isSearchable is false, react-select will create its own dummy input instead of using ours,
          // so we need to manually add the additional aria-describedby using ref.
          var input = (_this$select = this.select) === null || _this$select === void 0 ? void 0 : _this$select.inputRef;
          var ariaDescribedby = input === null || input === void 0 ? void 0 : input.getAttribute('aria-describedby');
          if (!(ariaDescribedby !== null && ariaDescribedby !== void 0 && ariaDescribedby.includes(descriptionId))) {
            input === null || input === void 0 || input.setAttribute('aria-describedby', "".concat(ariaDescribedby, " ").concat(descriptionId));
          }
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
          styles = _this$props.styles,
          validationState = _this$props.validationState,
          isInvalid = _this$props.isInvalid,
          spacing = _this$props.spacing,
          isMulti = _this$props.isMulti,
          appearance = _this$props.appearance,
          ariaLiveMessages = _this$props.ariaLiveMessages,
          props = _objectWithoutProperties(_this$props, _excluded);
        var isCompact = spacing === 'compact';

        // props must be spread first to stop `components` being overridden
        return /*#__PURE__*/React.createElement(WrappedComponent, _extends({
          ref: this.onSelectRef,
          isMulti: isMulti,
          "aria-live": "assertive",
          ariaLiveMessages: isOptionsGrouped(this.props.options) ? _objectSpread({
            onFocus: onFocus
          }, ariaLiveMessages) : _objectSpread({}, ariaLiveMessages)
        }, props, {
          components: this.components,
          styles: mergeStyles(baseStyles(
          // This will cover both props for invalid state while giving priority to isInvalid. When cleaning up validationState, we can just keep the inner condition.
          typeof isInvalid !== 'undefined' ? isInvalid ? 'error' : 'default' : validationState, isCompact, this.props.appearance || 'default'), styles)
        }));
      }
    }]);
    return AtlaskitSelect;
  }(Component), _defineProperty(_class, "defaultProps", {
    validationState: 'default',
    // TODO: uncomment the next line when cleaning up validationState prop so it has a default value
    // isInvalid: false,
    spacing: 'default',
    onClickPreventDefault: true,
    tabSelectsValue: false,
    components: {
      Input: Input
    },
    styles: {}
  }), _class;
}