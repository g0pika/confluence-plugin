import _extends from "@babel/runtime/helpers/extends";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import React, { Component } from 'react';
import { mergeStyles } from 'react-select';
import memoizeOne from 'memoize-one';
import isEqual from 'react-fast-compare';
import { Input } from './components/input-aria-describedby';
import { ClearIndicator, DropdownIndicator, LoadingIndicator, MultiValueRemove, IndicatorSeparator } from './components';
import baseStyles from './styles';
import { onFocus, isOptionsGrouped } from './utils/grouped-options-announcement';
export default function createSelect(WrappedComponent) {
  var _class;
  return _class = class AtlaskitSelect extends Component {
    constructor(props) {
      super(props);
      _defineProperty(this, "components", {});
      _defineProperty(this, "select", null);
      _defineProperty(this, "cacheComponents", components => {
        this.components = {
          ClearIndicator: ClearIndicator ? ClearIndicator : undefined,
          DropdownIndicator,
          LoadingIndicator,
          MultiValueRemove,
          IndicatorSeparator,
          ...components
        };
      });
      _defineProperty(this, "onSelectRef", ref => {
        this.select = ref;
      });
      this.cacheComponents = memoizeOne(this.cacheComponents, isEqual).bind(this);
      this.cacheComponents(props.components || {});
    }
    UNSAFE_componentWillReceiveProps(nextProps) {
      this.cacheComponents(nextProps.components);
    }
    focus() {
      if (this.select) {
        this.select.focus();
      }
    }
    blur() {
      if (this.select) {
        this.select.blur();
      }
    }
    componentDidMount() {
      const descriptionId = this.props['aria-describedby'];
      if (!this.props.isSearchable && descriptionId) {
        var _this$select;
        // when isSearchable is false, react-select will create its own dummy input instead of using ours,
        // so we need to manually add the additional aria-describedby using ref.
        const input = (_this$select = this.select) === null || _this$select === void 0 ? void 0 : _this$select.inputRef;
        const ariaDescribedby = input === null || input === void 0 ? void 0 : input.getAttribute('aria-describedby');
        if (!(ariaDescribedby !== null && ariaDescribedby !== void 0 && ariaDescribedby.includes(descriptionId))) {
          input === null || input === void 0 ? void 0 : input.setAttribute('aria-describedby', `${ariaDescribedby} ${descriptionId}`);
        }
      }
    }
    render() {
      const {
        styles,
        validationState,
        isInvalid,
        spacing,
        isMulti,
        appearance,
        ariaLiveMessages,
        ...props
      } = this.props;
      const isCompact = spacing === 'compact';

      // props must be spread first to stop `components` being overridden
      return /*#__PURE__*/React.createElement(WrappedComponent, _extends({
        ref: this.onSelectRef,
        isMulti: isMulti,
        "aria-live": "assertive",
        ariaLiveMessages: isOptionsGrouped(this.props.options) ? {
          onFocus,
          ...ariaLiveMessages
        } : {
          ...ariaLiveMessages
        }
      }, props, {
        components: this.components,
        styles: mergeStyles(baseStyles(
        // This will cover both props for invalid state while giving priority to isInvalid. When cleaning up validationState, we can just keep the inner condition.
        typeof isInvalid !== 'undefined' ? isInvalid ? 'error' : 'default' : validationState, isCompact, this.props.appearance || 'default'), styles)
      }));
    }
  }, _defineProperty(_class, "defaultProps", {
    validationState: 'default',
    // TODO: uncomment the next line when cleaning up validationState prop so it has a default value
    // isInvalid: false,
    spacing: 'default',
    onClickPreventDefault: true,
    tabSelectsValue: false,
    components: {
      Input
    },
    styles: {}
  }), _class;
}