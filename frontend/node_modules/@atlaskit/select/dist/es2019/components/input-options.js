import _extends from "@babel/runtime/helpers/extends";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
/** @jsx jsx */
import { css, jsx } from '@emotion/react';
import { Component } from 'react';
import { getBooleanFF } from '@atlaskit/platform-feature-flags';
import RadioIcon from '@atlaskit/icon/glyph/radio';
import CheckboxIcon from '@atlaskit/icon/glyph/checkbox';
import { B300, B400, B75, N20A, N0, N100, N20, N30, N70 } from '@atlaskit/theme/colors';
const getPrimitiveStyles = props => {
  const {
    cx,
    className,
    getStyles,
    isDisabled,
    isFocused,
    isSelected
  } = props;
  const baseStyles = {
    alignItems: 'center',
    backgroundColor: isFocused ? `var(--ds-background-neutral-subtle-hovered, ${N20})` : 'transparent',
    color: isDisabled ? "var(--ds-text-disabled, inherit)" : 'inherit',
    display: 'flex ',
    paddingBottom: "var(--ds-space-050, 4px)",
    paddingLeft: "var(--ds-space-200, 16px)",
    paddingTop: "var(--ds-space-050, 4px)",
    // This 'none' needs to be present to ensure that style is not applied when
    // the option is selected but not focused.
    boxShadow: isFocused ? `inset 2px 0px 0px ${`var(--ds-border-focused, ${B400})`}` : 'none',
    ':active': {
      backgroundColor: `var(--ds-background-neutral-subtle-pressed, ${N30})`
    },
    '@media screen and (-ms-high-contrast: active)': {
      borderLeft: isFocused ? '2px solid transparent' : ''
    }
  };
  const augmentedStyles = css({
    ...getStyles('option', props),
    ...baseStyles
  });
  const bemClasses = {
    option: true,
    'option--is-disabled': isDisabled,
    'option--is-focused': isFocused,
    'option--is-selected': isSelected
  };

  // maintain react-select API
  return [augmentedStyles, cx(bemClasses, className)];
};

// state of the parent option

// the primary color represents the outer or background element
const getPrimaryColor = ({
  isActive,
  isDisabled,
  isFocused,
  isSelected
}) => {
  if (isDisabled && isSelected) {
    return `var(--ds-background-disabled, ${B75})`;
  } else if (isDisabled) {
    return `var(--ds-background-disabled, ${N20A})`;
  } else if (isSelected && isActive) {
    return `var(--ds-background-selected-bold-pressed, ${B75})`;
  } else if (isActive) {
    return `var(--ds-background-selected-pressed, ${B75})`;
  } else if (isFocused && isSelected) {
    return `var(--ds-background-selected-bold-hovered, ${B300})`;
  } else if (isFocused) {
    return `var(--ds-surface, ${N0})`;
  } else if (isSelected) {
    return `var(--ds-background-selected-bold, ${B400})`;
  }
  return `var(--ds-background-neutral, ${N0})`;
};

// the secondary color represents the radio dot or checkmark
const getSecondaryColor = ({
  isActive,
  isDisabled,
  isSelected
}) => {
  if (isDisabled && isSelected) {
    return `var(--ds-text-disabled, ${N70})`;
  } else if (isActive && isSelected && !isDisabled) {
    return `var(--ds-surface, ${B400})`;
  } else if (!isSelected) {
    return 'transparent';
  }
  return `var(--ds-surface, ${N0})`;
};

// the border color surrounds the checkbox/radio
const getBorderColor = ({
  isActive,
  isDisabled,
  isFocused,
  isSelected
}) => {
  if (isDisabled && isSelected) {
    return `var(--ds-background-disabled, ${B400})`;
  } else if (isDisabled) {
    return `var(--ds-background-disabled, ${N100})`;
  } else if (isSelected && isActive) {
    return `var(--ds-background-selected-bold-pressed, ${B400})`;
  } else if (isActive) {
    return `var(--ds-background-selected-bold, ${B400})`;
  } else if (isFocused && isSelected) {
    return `var(--ds-background-selected-bold-hovered, ${B400})`;
  } else if (isFocused) {
    return `var(--ds-border-input, ${N100})`;
  } else if (isSelected) {
    return `var(--ds-background-selected-bold, ${B400})`;
  }
  return `var(--ds-border-input, ${N100})`;
};
const baseIconStyles = css({
  alignItems: 'center',
  display: 'flex ',
  flexShrink: 0,
  paddingInlineEnd: "var(--ds-space-050, 4px)",
  // Here we are adding a border to the Checkbox and Radio SVG icons
  // This is an a11y fix for Select only for now but it may be rolled
  // into the `@atlaskit/icon` package's Checkbox and Radio SVGs later
  // eslint-disable-next-line @atlaskit/design-system/no-nested-styles
  '& svg rect, & svg circle:first-of-type': {
    strokeWidth: getBooleanFF('platform.design-system-team.border-checkbox_nyoiu') ? "var(--ds-border-width, 1px)" : "var(--ds-border-width-outline, 2px)",
    strokeLinejoin: 'round'
  }
});
const baseOptionStyles = css({
  textOverflow: 'ellipsis',
  overflowX: 'hidden',
  flexGrow: 1,
  whiteSpace: 'nowrap'
});
class ControlOption extends Component {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "state", {
      isActive: false
    });
    _defineProperty(this, "onMouseDown", () => this.setState({
      isActive: true
    }));
    _defineProperty(this, "onMouseUp", () => this.setState({
      isActive: false
    }));
    _defineProperty(this, "onMouseLeave", () => this.setState({
      isActive: false
    }));
  }
  render() {
    const {
      getStyles,
      Icon,
      children,
      innerProps,
      innerRef,
      ...rest
    } = this.props;

    // prop assignment
    const props = {
      ...innerProps,
      onMouseDown: this.onMouseDown,
      onMouseUp: this.onMouseUp,
      onMouseLeave: this.onMouseLeave
    };
    const [styles, classes] = getPrimitiveStyles({
      getStyles,
      ...rest
    });
    return (
      // These need to remain this way because `react-select` passes props with
      // styles inside, and that must be done dynamically.
      // eslint-disable-next-line @atlaskit/design-system/consistent-css-prop-usage
      jsx("div", _extends({
        css: styles,
        className: classes,
        ref: innerRef
      }, props), jsx("div", {
        css: [baseIconStyles,
        // Here we are adding a border to the Checkbox and Radio SVG icons
        // This is an a11y fix for Select only for now but it may be rolled
        // into the `@atlaskit/icon` package's Checkbox and Radio SVGs later
        // eslint-disable-next-line @atlaskit/design-system/consistent-css-prop-usage
        {
          // This can eventually be changed to static styles that are
          // applied conditionally (e.g. `isActive && activeBorderStyles`),
          // but considering there are multiple instances of `react-select`
          // requiring styles to be generated dynamically, it seemed like a
          // low priority.
          // eslint-disable-next-line @atlaskit/design-system/no-nested-styles
          '& svg rect, & svg circle:first-of-type': {
            stroke: getBorderColor({
              ...this.props,
              ...this.state
            })
          }
        }]
      }, !!Icon ? jsx(Icon, {
        label: "",
        primaryColor: getPrimaryColor({
          ...this.props,
          ...this.state
        }),
        secondaryColor: getSecondaryColor({
          ...this.props,
          ...this.state
        })
      }) : null), jsx("div", {
        css: baseOptionStyles
      }, children))
    );
  }
}
export const CheckboxOption = props => jsx(ControlOption, _extends({
  Icon: CheckboxIcon
}, props));
export const RadioOption = props => jsx(ControlOption, _extends({
  Icon: RadioIcon
}, props));