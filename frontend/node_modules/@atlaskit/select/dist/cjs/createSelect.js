"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createSelect;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _react = _interopRequireWildcard(require("react"));
var _reactSelect = require("react-select");
var _memoizeOne = _interopRequireDefault(require("memoize-one"));
var _reactFastCompare = _interopRequireDefault(require("react-fast-compare"));
var _inputAriaDescribedby = require("./components/input-aria-describedby");
var _components = require("./components");
var _styles = _interopRequireDefault(require("./styles"));
var _groupedOptionsAnnouncement = require("./utils/grouped-options-announcement");
var _excluded = ["styles", "validationState", "isInvalid", "spacing", "isMulti", "appearance", "ariaLiveMessages"];
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function createSelect(WrappedComponent) {
  var _class;
  return _class = /*#__PURE__*/function (_Component) {
    (0, _inherits2.default)(AtlaskitSelect, _Component);
    var _super = _createSuper(AtlaskitSelect);
    function AtlaskitSelect(props) {
      var _this;
      (0, _classCallCheck2.default)(this, AtlaskitSelect);
      _this = _super.call(this, props);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "components", {});
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "select", null);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "cacheComponents", function (components) {
        _this.components = _objectSpread({
          ClearIndicator: _components.ClearIndicator ? _components.ClearIndicator : undefined,
          DropdownIndicator: _components.DropdownIndicator,
          LoadingIndicator: _components.LoadingIndicator,
          MultiValueRemove: _components.MultiValueRemove,
          IndicatorSeparator: _components.IndicatorSeparator
        }, components);
      });
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "onSelectRef", function (ref) {
        _this.select = ref;
      });
      _this.cacheComponents = (0, _memoizeOne.default)(_this.cacheComponents, _reactFastCompare.default).bind((0, _assertThisInitialized2.default)(_this));
      _this.cacheComponents(props.components || {});
      return _this;
    }
    (0, _createClass2.default)(AtlaskitSelect, [{
      key: "UNSAFE_componentWillReceiveProps",
      value: function UNSAFE_componentWillReceiveProps(nextProps) {
        this.cacheComponents(nextProps.components);
      }
    }, {
      key: "focus",
      value: function focus() {
        if (this.select) {
          this.select.focus();
        }
      }
    }, {
      key: "blur",
      value: function blur() {
        if (this.select) {
          this.select.blur();
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var descriptionId = this.props['aria-describedby'];
        if (!this.props.isSearchable && descriptionId) {
          var _this$select;
          // when isSearchable is false, react-select will create its own dummy input instead of using ours,
          // so we need to manually add the additional aria-describedby using ref.
          var input = (_this$select = this.select) === null || _this$select === void 0 ? void 0 : _this$select.inputRef;
          var ariaDescribedby = input === null || input === void 0 ? void 0 : input.getAttribute('aria-describedby');
          if (!(ariaDescribedby !== null && ariaDescribedby !== void 0 && ariaDescribedby.includes(descriptionId))) {
            input === null || input === void 0 || input.setAttribute('aria-describedby', "".concat(ariaDescribedby, " ").concat(descriptionId));
          }
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
          styles = _this$props.styles,
          validationState = _this$props.validationState,
          isInvalid = _this$props.isInvalid,
          spacing = _this$props.spacing,
          isMulti = _this$props.isMulti,
          appearance = _this$props.appearance,
          ariaLiveMessages = _this$props.ariaLiveMessages,
          props = (0, _objectWithoutProperties2.default)(_this$props, _excluded);
        var isCompact = spacing === 'compact';

        // props must be spread first to stop `components` being overridden
        return /*#__PURE__*/_react.default.createElement(WrappedComponent, (0, _extends2.default)({
          ref: this.onSelectRef,
          isMulti: isMulti,
          "aria-live": "assertive",
          ariaLiveMessages: (0, _groupedOptionsAnnouncement.isOptionsGrouped)(this.props.options) ? _objectSpread({
            onFocus: _groupedOptionsAnnouncement.onFocus
          }, ariaLiveMessages) : _objectSpread({}, ariaLiveMessages)
        }, props, {
          components: this.components,
          styles: (0, _reactSelect.mergeStyles)((0, _styles.default)(
          // This will cover both props for invalid state while giving priority to isInvalid. When cleaning up validationState, we can just keep the inner condition.
          typeof isInvalid !== 'undefined' ? isInvalid ? 'error' : 'default' : validationState, isCompact, this.props.appearance || 'default'), styles)
        }));
      }
    }]);
    return AtlaskitSelect;
  }(_react.Component), (0, _defineProperty2.default)(_class, "defaultProps", {
    validationState: 'default',
    // TODO: uncomment the next line when cleaning up validationState prop so it has a default value
    // isInvalid: false,
    spacing: 'default',
    onClickPreventDefault: true,
    tabSelectsValue: false,
    components: {
      Input: _inputAriaDescribedby.Input
    },
    styles: {}
  }), _class;
}