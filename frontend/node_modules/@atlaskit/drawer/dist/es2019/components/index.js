import React, { Children, Component, Fragment, } from 'react';
import { canUseDOM } from 'exenv';
import { Transition, TransitionGroup } from 'react-transition-group';
import { ThemeProvider } from 'styled-components';
import { createAndFireEvent, withAnalyticsContext, withAnalyticsEvents, } from '@atlaskit/analytics-next';
import Blanket from '@atlaskit/blanket';
import Portal from '@atlaskit/portal';
import { transitionDurationMs } from '../constants';
import drawerItemTheme from '../theme/drawer-item-theme';
import { name as packageName, version as packageVersion, } from '../version.json';
import FocusLock from './focus-lock';
import DrawerPrimitive from './primitives';
import { Fade } from './transitions';
const OnlyChild = ({ children }) => Children.toArray(children)[0] || null;
const createAndFireEventOnAtlaskit = createAndFireEvent('atlaskit');
const createAndFireOnClick = (createAnalyticsEvent, trigger) => createAndFireEventOnAtlaskit({
    action: 'dismissed',
    actionSubject: 'drawer',
    attributes: {
        componentName: 'drawer',
        packageName,
        packageVersion,
        trigger,
    },
})(createAnalyticsEvent);
export class DrawerBase extends Component {
    constructor() {
        super(...arguments);
        this.state = {
            renderPortal: false,
        };
        this.body = canUseDOM ? document.querySelector('body') : undefined;
        this.handleBlanketClick = (event) => {
            this.handleClose(event, 'blanket');
        };
        this.handleBackButtonClick = (event) => {
            this.handleClose(event, 'backButton');
        };
        this.handleClose = (event, trigger) => {
            const { createAnalyticsEvent, onClose } = this.props;
            const analyticsEvent = createAnalyticsEvent &&
                createAndFireOnClick(createAnalyticsEvent, trigger);
            if (onClose) {
                onClose(event, analyticsEvent);
            }
        };
        this.handleKeyDown = (event) => {
            const { isOpen, onKeyDown } = this.props;
            if (event.key === 'Escape' && isOpen) {
                this.handleClose(event, 'escKey');
            }
            if (onKeyDown) {
                onKeyDown(event);
            }
        };
    }
    componentDidMount() {
        const { isOpen } = this.props;
        if (isOpen) {
            window.addEventListener('keydown', this.handleKeyDown);
        }
    }
    componentWillUnmount() {
        window.removeEventListener('keydown', this.handleKeyDown);
    }
    componentDidUpdate(prevProps) {
        const { isOpen } = this.props;
        if (isOpen !== prevProps.isOpen) {
            if (isOpen) {
                window.addEventListener('keydown', this.handleKeyDown);
            }
            else {
                window.removeEventListener('keydown', this.handleKeyDown);
            }
        }
    }
    render() {
        if (!this.body) {
            return null;
        }
        const { isOpen, children, icon, width, shouldUnmountOnExit, onCloseComplete, onOpenComplete, autoFocusFirstElem, isFocusLockEnabled, shouldReturnFocus, overrides, } = this.props;
        return (React.createElement(Transition, { in: isOpen, timeout: { enter: 0, exit: transitionDurationMs }, mountOnEnter: true, unmountOnExit: true },
            React.createElement(Portal, { zIndex: "unset" },
                React.createElement(TransitionGroup, { component: OnlyChild },
                    React.createElement(Fragment, null,
                        React.createElement(Fade, { in: isOpen },
                            React.createElement(Blanket, { isTinted: true, onBlanketClicked: this.handleBlanketClick })),
                        React.createElement(FocusLock, { autoFocusFirstElem: autoFocusFirstElem, isFocusLockEnabled: isFocusLockEnabled, shouldReturnFocus: shouldReturnFocus },
                            React.createElement(DrawerPrimitive, { icon: icon, in: isOpen, onClose: this.handleBackButtonClick, onCloseComplete: onCloseComplete, onOpenComplete: onOpenComplete, width: width, shouldUnmountOnExit: shouldUnmountOnExit, overrides: overrides }, children)))))));
    }
}
DrawerBase.defaultProps = {
    width: 'narrow',
    isFocusLockEnabled: true,
    shouldReturnFocus: true,
    autoFocusFirstElem: false,
};
export const DrawerItemTheme = (props) => (React.createElement(ThemeProvider, { theme: drawerItemTheme }, props.children));
export * from './skeletons';
export * from './item-group';
export * from './item';
export default withAnalyticsContext({
    componentName: 'drawer',
    packageName,
    packageVersion,
})(withAnalyticsEvents()(DrawerBase));
//# sourceMappingURL=index.js.map